/*********************************************************************************
* Licensed Materials - Property of IBM
 * 5655-TAC
 * (C) Copyright IBM Corp. 2013 All Rights Reserved. 
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with 
 * IBM Corp.               
 *********************************************************************************/

package com.ibm.ims.ea.om.common.services;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.Map;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.im.ac.datastore.DatastoreException;
import com.ibm.ims.ea.base.version.Version;
import com.ibm.ims.ea.om.cmd.constants.ImsCommandAttributes;
import com.ibm.ims.ea.om.cmd.exceptions.OmCommandGenerationException;
import com.ibm.ims.ea.om.cmd.utilities.Type2CommandSerializable;
import com.ibm.ims.ea.om.cmd.v14.query.ims.QueryIms;
import com.ibm.ims.ea.om.cmd.v14.query.imsplex.QueryImsPlex;
import com.ibm.ims.ea.om.cmd.v14.type2.Type2Command;
import com.ibm.ims.ea.om.common.exception.OmConnectionException;
import com.ibm.ims.ea.om.common.exception.OmDatastoreException;
import com.ibm.ims.ea.om.common.exception.OmException;
import com.ibm.ims.ea.om.common.exception.OmRuntimeException;
import com.ibm.ims.ea.om.common.message.OmInteractionContext;
import com.ibm.ims.ea.om.common.result.OmResultSet;
import com.ibm.ims.ea.om.common.service.ImsService;
import com.ibm.ims.ea.om.datastore.ImsBaseDastoreConstants;
import com.ibm.ims.ea.om.datastore.ImsOmDatastore;
import com.ibm.ims.ea.om.datastore.OmImsTable;
import com.ibm.ims.ea.om.datastore.OmMemberTable;
import com.ibm.ims.ea.om.ims.Ims;
import com.ibm.ims.ea.om.ims.Ims.ImsResponseAttribute;
import com.ibm.ims.ea.om.imsplex.Imsplex;

/**
 * <pre>
 * Class provides methods to interact with OM for the IMS resource. 
 * Return types are generalized for all interactions as a Collection of {@link Imsplex} objects. 
 * 
 * It should be noted that the Collection only manages the response for the particular 
 * resource and that OM Messages including Reason Codes, Reason Text, etc are accessible 
 * from the {@link Om} instance managing the interaction. 
 * 
 * See  <code>{@link Om#getOmMessageContexts()} </code> on how to access OM Messages.
 * </pre>
 * 
 * @author ddgandhi
 *
 */
public final class ImsServices extends ServicesHelper implements ImsService {
    private static final Logger logger = LoggerFactory.getLogger(ImsServices.class);
    private static final String CSL = "CSL"; //Prefix used for IMSnames 
  
    //Statically build a mem-cache of all the known discovered meta-data about this service resulting from discovery
    static{
    	//Try to get an instance of the com.ibm.im.ac.datastore 
		ImsOmDatastore imsOMDatastore;
		try {
			imsOMDatastore = ImsOmDatastore.getInstance();
			
			//Build the meta-data for ims table
			OmImsTable omImsTable = imsOMDatastore.getOmImsStore();
			if(omImsTable != null){
				omImsTable.autoConfigureResourceMetaData();
			}
			
		} catch (DatastoreException e) {
			//This exception will only happen if dependency "com.ibm.im.ac.datastore" has not been
			//loaded by OSGI. Moving this logic to Declarative serivces might be a good option. 
			
			if(logger.isDebugEnabled()){
				logger.debug("Appears that the bundle for service com.ibm.im.ac.datastore.AbstractDatastore has not been loaded");
			}
		}
    }
    
    static{
    	//Try to get an instance of the com.ibm.im.ac.datastore 
		ImsOmDatastore imsOMDatastore;
		try {
			imsOMDatastore = ImsOmDatastore.getInstance();
			
			//Build the meta-data for member table
			OmMemberTable omMemberTable = imsOMDatastore.getOmMemberStore();
			if(omMemberTable != null){
				omMemberTable.autoConfigureResourceMetaData();
			}
			
		} catch (DatastoreException e) {
			System.out.println("DO NOTHING , BUNDLE DEPENDENCY NOT LOADED");
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
    
    //This must remain protected else the Om instance will not be able to aggregate all the Om Messages
    protected ImsServices(Om om) {
    	super(om);
    	
		try {
			this.resourceVersion = om.getImsplexService().getResourceVersions(new QueryImsPlex.TypeOptions[]{QueryImsPlex.TypeOptions.IMS});
		} catch (Exception e) {
			version = Version.IMS_ZERO_RELEASE;
		}
    }

// ************************************************************************************************************
// * Get Ims's 
// ************************************************************************************************************
    @Override
    public Collection<Ims> getIms() throws OmException, OmConnectionException, OmDatastoreException {
    	if(logger.isDebugEnabled()) logger.debug(">> getIms()");
    	
    	try{
    		return getIms(new String[]{ImsCommandAttributes.ASTERISK});
    	}finally{
    		if(logger.isDebugEnabled()) logger.debug("<< getIms()");
    	}
    }

    @Override
    public Collection<Ims> getIms(String[] imsSystemName) throws OmException, OmConnectionException, OmDatastoreException {
        if (logger.isDebugEnabled()) logger.debug(">> getIms("+Arrays.toString(imsSystemName)+")"); 
        
        int resourceCacheSize = 0;
		Date date = null;
		ArrayList<String> imsAttributes = null;
		
		//Note the method key to be used for associating the service
		String methodKey = "getIms"; 
		
		//Local omresultSet otherwise we risk data corruption of the service is reused. 
		OmResultSet omResultSet = null;
		
        String imsplexNameTemp = CSL.concat(this.imsplexName);
       
        try {
        	
        	imsSystemName = this.routeMemberFormater(imsSystemName);
        	
        	//Set and configure the version using mapped resource version and the route name
        	this.version = this.setVersion(this.resourceVersion , imsSystemName);
        	
        	/** Case: If it is not live then enter this block otherwise drop down to the live code **/
        	if(!this.om.isInteractionModeLive()){

        		//Create a connection to OmIms table (cache) datastore 
        		OmImsTable omImsTable = ImsOmDatastore.getInstance().getOmImsStore();

        		//Size greater than 0 then transactions have been discovered
				resourceCacheSize = omImsTable.getCountFromMemoryCache(this.sysplexId, imsplexNameTemp, imsSystemName) ;
				
				if( resourceCacheSize > 0){
			        //Set the date the discovery was done
					date = omImsTable.getLastestDateFromMemoryCache(sysplexId, imsplexNameTemp,imsSystemName);
					
					//Set the imsattributes that are in the memcache
					imsAttributes = ImsOmDatastore.getInstance().getGridHeaderTable().getGridHeadersMemCache(version.toString(), methodKey);
					
			        /** Case: interaction mode is DEFAULT or CACHE**/
			        return omImsTable.getIms(this.sysplexId,  imsplexNameTemp, imsSystemName, null);
				}
        	}

        	/**Case: No discovery has been run, continue to operate without the cache (live mode)*/
        	//Query Ims for SHOW(ALL) and status
        	Type2Command type2Command = new Type2Command();
        	type2Command.setVerb(Type2Command.VerbOptions.QUERY);
        	type2Command.setResource(Type2Command.ResourceOptions.IMS);
        	type2Command.getRoute().addAll(Arrays.asList(imsSystemName));
        	
        	QueryIms queryIms = new QueryIms();
        	queryIms.getSHOW().add(QueryIms.ShowOptions.LOCAL); // SHOW(ALL) returns global and local values 
        	
        	type2Command.setQueryIms(queryIms);
        	
        	Type2CommandSerializable type2CommandSerializable = new Type2CommandSerializable();
        	String cmd = type2CommandSerializable.fromType2CommandObject(type2Command);
        	
        	Service service = new Service(this.om, this.version);
			omResultSet = service.executeCommand(methodKey,cmd);

            //Convert the omResponse to a collection to be returned
            return propertiesToCollection(omResultSet);
   		 
        } catch (OmDatastoreException e) {
        	e.setImsplexName(imsplexNameTemp);
        	throw e;
        } catch (DatastoreException e) {
        	throw convertDatatstoreException(e, this.sysplexId, imsplexNameTemp);
        } catch (OmCommandGenerationException e) {
        	throw new OmRuntimeException(e);
        } finally {
            if (logger.isDebugEnabled()) logger.debug("<< getIms("+Arrays.toString(imsSystemName)+")");
            
            this.setOmInteractionContext(omResultSet,resourceCacheSize, date, imsAttributes, methodKey);
        }
    }

    //****************************************************************************************************
    // Get Repo info 
    //****************************************************************************************************
   
    public Collection<Ims> getRepoInfo(String[] imsSystemName) throws OmException, OmConnectionException, OmDatastoreException {
        if (logger.isDebugEnabled()) logger.debug(">> getRepoInfo("+Arrays.toString(imsSystemName)+")"); 
        
        int resourceCacheSize = 0;
		Date date = null;
		ArrayList<String> imsAttributes = null;
		
        //Note the method key to be used for associating the service
        String methodKey = "getRepoInfo"; 
      		
        //Local omresultSet otherwise we risk data corruption of the service is reused. 
      	OmResultSet omResultSet = null;
      		
        String imsplexNameTemp = CSL.concat(this.imsplexName);
       
        try {
        	imsSystemName = this.routeMemberFormater(imsSystemName);
        	
        	//Set and configure the version using mapped resource version and the route name
        	this.version = this.setVersion(this.resourceVersion , imsSystemName);
        	
        	/** Case: If it is not live then enter this block otherwise drop down to the live code **/
        	if(!this.om.isInteractionModeLive()){

        		//Create a connection to OmIms table (cache) datastore 
        		OmImsTable omImsTable = ImsOmDatastore.getInstance().getOmImsStore();

        		//Size greater than 0 then transactions have been discovered
				resourceCacheSize = omImsTable.getCountFromMemoryCache(this.sysplexId, imsplexNameTemp, imsSystemName);
				
				if( resourceCacheSize > 0){
			        //Set the date the discovery was done
					date = omImsTable.getLastestDateFromMemoryCache(sysplexId, imsplexNameTemp,imsSystemName);
					
					//Set the imsattributes that are in the memcache
					imsAttributes = ImsOmDatastore.getInstance().getGridHeaderTable().getGridHeadersMemCache(version.toString(), methodKey);
					
			        /** Case: interaction mode is DEFAULT **/
			        return omImsTable.getRepoInfo(this.sysplexId,  imsplexNameTemp, imsSystemName, null);
				}
        	}

        	/**Case: No discovery has been run, continue to operate without the cache (live mode)*/
        	//Query Ims for SHOW(ALL) and status
        	Type2Command type2Command = new Type2Command();
        	type2Command.setVerb(Type2Command.VerbOptions.QUERY);
        	type2Command.setResource(Type2Command.ResourceOptions.IMS);
        	type2Command.getRoute().addAll(Arrays.asList(imsSystemName));
        	
        	QueryIms queryIms = new QueryIms();
        	queryIms.getTYPE().add(QueryIms.TypeOptions.LCLPARM);
        	queryIms.getSHOW().add(QueryIms.ShowOptions.REPO);  
        	
        	type2Command.setQueryIms(queryIms);
        	
        	Type2CommandSerializable type2CommandSerializable = new Type2CommandSerializable();
        	String cmd = type2CommandSerializable.fromType2CommandObject(type2Command);
        	
        	Service service = new Service(this.om, this.version);
			omResultSet = service.executeCommand(methodKey,cmd);

            //Convert the omResponse to a collection to be returned
            return propertiesToCollection(omResultSet);
   		 
        } catch (OmDatastoreException e) {
        	e.setImsplexName(imsplexNameTemp);
        	throw e;
        } catch (DatastoreException e) {
        	throw convertDatatstoreException(e, this.sysplexId, imsplexNameTemp);
        } catch (OmCommandGenerationException e) {
        	throw new OmRuntimeException(e);
        } finally {
            if (logger.isDebugEnabled()) logger.debug("<< getRepoInfo("+Arrays.toString(imsSystemName)+")");
            
            this.setOmInteractionContext(omResultSet,resourceCacheSize, date, imsAttributes, methodKey);
        }
    }

// ************************************************************************************************************
// * Discovery members
// ************************************************************************************************************
	
	@Override
	public int discoverIms() throws OmDatastoreException, OmException, OmConnectionException{
		if (logger.isDebugEnabled()) logger.debug(">> discoverIms()");
		
		try{
			Collection<Ims> imses = om.getImsService().getIms();
			int insertionSize = 0;
			
			for(Ims ims: imses){
				String mbrName = ims.getProperty(ImsResponseAttribute.MBR);
				insertionSize += this.discoverIms(mbrName);
			}
			
			return insertionSize;
		}finally{
			 if (logger.isDebugEnabled()) logger.debug("<< discoverIms()");
		}
	}
	    
    @Override
	public int discoverIms(String imsSystemName) throws OmDatastoreException, OmException, OmConnectionException {
    	if (logger.isDebugEnabled()) logger.debug(">> discoverIms("+imsSystemName+")");
    	
		String imsplexNameTemp  = CSL.concat(this.imsplexName);
		int insertionSize   = 0;
		
		try {
			this.isDiscovering = true;
			this.om.setInteractionMode(Om.InteractionMode.LIVE);
			Collection<Ims> ims = this.getIms(new String[]{imsSystemName});
			this.om.setInteractionMode(Om.InteractionMode.DEFAULT);
			
			// Create a connection to the ims table (cache) datastore
			OmImsTable imsImsTable = ImsOmDatastore.getInstance().getOmImsStore();

			// Clear the ims cache
			imsImsTable.deleteTable(sysplexId, imsplexNameTemp, imsSystemName);

			//Insert the response into Derby
			insertionSize = imsImsTable.addIms(ims, sysplexId, imsplexNameTemp);
			
			//Populate the meta-data with the latest update
			imsImsTable.autoConfigureResourceMetaData(sysplexId, imsplexNameTemp, imsSystemName); 

			//Since the discovery was run in live mode, we need to add to the omInteractionContext the size and Date
			String[] imsSystemNameArray = new String[]{imsSystemName};
			int resourceCacheSize = imsImsTable.getCountFromMemoryCache(sysplexId, imsplexNameTemp, imsSystemNameArray);
			Date date = imsImsTable.getLastestDateFromMemoryCache(sysplexId, imsplexNameTemp, imsSystemNameArray);
			
			OmInteractionContext omInteractionContext = this.om.getOmInteractionContexts().get("getIms");
			omInteractionContext.setResourceLastUpdated(date);
			omInteractionContext.setResourceCacheSize(resourceCacheSize);
			
			return insertionSize;
		} catch (OmDatastoreException e) {
			e.setImsplexName(this.om.getOMConnection().getImsplex());
			throw e;
		} catch (DatastoreException e) {
			throw convertDatatstoreException(e, sysplexId, imsplexNameTemp);
		} finally{
			if (logger.isDebugEnabled()) logger.debug("<< discoverIms("+imsSystemName+")");
		}
	}
// ************************************************************************************************************
// * PRIVATE MEMBER HELPERS
// ************************************************************************************************************  
    /**
	 * Method will map a omResulset to a collection of ims beans. It will also
	 * append to each bean the sysplex and imsplex name. 
	 * @param omResultSet
	 * @return
	 */
    private Collection<Ims> propertiesToCollection(OmResultSet omResultSet) {
        Collection<Ims> tempList = new ArrayList<Ims>();

            Properties[] properties = omResultSet.getResponseProperties();

            for (Properties p : properties) {
            	Ims ims = new Ims();
            	ims.setMap((Map)p);
            	ims.getMap().put(ImsBaseDastoreConstants.SYSPLEX_ID, omResultSet.getEnvironment());
            	ims.getMap().put(ImsBaseDastoreConstants.IMSPLX, omResultSet.getImsplex());
                tempList.add(ims);
            }

        return tempList;
    }

}
