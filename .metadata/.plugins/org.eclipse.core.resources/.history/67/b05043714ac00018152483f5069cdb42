/*********************************************************************************
 * Licensed Materials - Property of IBM
 * 5655-TAC
 * (C) Copyright IBM Corp. 2015 All Rights Reserved. 
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with 
 * IBM Corp.               
 *********************************************************************************/
package com.ibm.ims.ea.om.datastore;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.EnumSet;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.im.ac.datastore.Datastore;
import com.ibm.im.ac.datastore.DatastoreException;
import com.ibm.im.ac.datastore.impl.SysplexTable;
import com.ibm.ims.ea.base.utils.ArrayUtils;
import com.ibm.ims.ea.om.cmd.v14.query.imsplex.QueryImsPlex;
import com.ibm.ims.ea.om.common.exception.OmConnectionException;
import com.ibm.ims.ea.om.common.exception.OmDatastoreException;
import com.ibm.ims.ea.om.common.exception.OmException;
import com.ibm.ims.ea.om.common.services.Om;
import com.ibm.ims.ea.om.imsplex.Imsplex;
import com.ibm.ims.ea.om.imsplex.Imsplex.ImsplexResponseAttribute;

/**
 * <pre>
 * Table storing information about IMSPLEXES. 
 * This table is a cache for all the IMSPlex Members and some additional fields used by the caller.
 *
 IMSPLEX_MBR_ID IMSPLX   MBR   STYP   JOB     TYP    IMSMBR  VER    STT          OS      CC   SYSPLEX_ID UPDATED
 -------------- -------- ----- ------ ------- ------ ------- ------ ------------ ------- ---- ---------- -----------------------
             96 CSLPLEX1 OM1OM        ODBM2   ODBM   ODBM2OD 1.3.0  READY,ACTIVE EC03126    0          1 2014-10-10 16:25:21.016
             97 CSLPLEX1 OM1OM        OM1     OM     OM1OM   1.6.0  READY,ACTIVE EC03127    0          1 2014-10-10 16:25:21.021
             98 CSLPLEX1 OM1OM        HWS1    IMSCON HWS1    13.1.0 ACTIVE       EC03127    0          1 2014-10-10 16:25:21.022
             99 CSLPLEX1 OM1OM        HWS2    IMSCON HWS2    13.1.0 ACTIVE       EC03126    0          1 2014-10-10 16:25:21.022
            100 CSLPLEX1 OM1OM        ODBM1   ODBM   ODBM1OD 1.3.0  READY,ACTIVE EC03127    0          1 2014-10-10 16:25:21.023
            101 CSLPLEX1 OM1OM        USRT011 AOP    USRT011 1.6.0  ACTIVE       EC03127    0          1 2014-10-10 16:25:21.024
            102 CSLPLEX1 OM1OM        SCI1    SCI    SCI1SC  1.6.0  READY,ACTIVE EC03127    0          1 2014-10-10 16:25:21.029
            103 CSLPLEX1 OM1OM        SCI2    SCI    SCI2SC  1.6.0  READY,ACTIVE EC03126    0          1 2014-10-10 16:25:21.029
            104 CSLPLEX1 OM1OM DBDC   IMS2    IMS    IMS2    13.1.0 READY,ACTIVE EC03126    0          1 2014-10-10 16:25:21.03
            105 CSLPLEX1 OM1OM SNGLRM RM1     RM     RM1RM   1.6.0  READY,ACTIVE EC03127    0          1 2014-10-10 16:25:21.031
            106 CSLPLEX1 OM1OM DBDC   IMS1    IMS    IMS1    13.1.0 READY,ACTIVE EC03127    0          1 2014-10-10 16:25:21.032
            107 CSLPLEX2 OM3OM DBDC   IMS3    IMS    IMS3    13.1.0 READY,ACTIVE EC03128    0          1 2014-10-10 16:26:08.747
            108 CSLPLEX2 OM3OM SNGLRM RM3     RM     RM3RM   1.6.0  READY,ACTIVE EC03128    0          1 2014-10-10 16:26:08.747
            109 CSLPLEX2 OM3OM        OM3     OM     OM3OM   1.6.0  READY,ACTIVE EC03128    0          1 2014-10-10 16:26:08.747
            110 CSLPLEX2 OM3OM        HWS3    IMSCON HWS3    13.1.0 ACTIVE       EC03128    0          1 2014-10-10 16:26:08.747
            111 CSLPLEX2 OM3OM        HWS1    IMSCON HWS1    13.1.0 ACTIVE       EC03127    0          1 2014-10-10 16:26:08.748
            112 CSLPLEX2 OM3OM        SCI2    SCI    SCIASC  1.6.0  READY,ACTIVE EC03127    0          1 2014-10-10 16:26:08.748
            113 CSLPLEX2 OM3OM        SCI3    SCI    SCI3SC  1.6.0  READY,ACTIVE EC03128    0          1 2014-10-10 16:26:08.748

 * 
 * IMSPLEX_MBR_ID     INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY
 * IMSPLX         VARCHAR(255) NOT NULL	
 * MBR     VARCHAR(255)	
 * STYP    VARCHAR(255) 
 * JOB     VARCHAR(255)	
 * TYP 	   VARCHAR(255)
 * IMSMBR  VARCHAR(255) 
 * VER     VARCHAR(255)
 * STT     VARCHAR(255)
 * OS      VARCHAR(255)
 * CC      VARCHAR(255)
 * PRIMARY KEY 	(IMSPLEX_MBR_ID)	
 * FOREIGN KEY 	(SYSPLEX_ID) REFERENCES SYSPLEX(SYSPLEX_ID) ON DELETE SET NULL)
 * 
 * @author ddgandhi
 *</pre>
 */
public class OmImsplexTable extends AbstractImsBaseDatastore implements OmImsplexStore {
    final static Logger logger = LoggerFactory.getLogger(OmImsplexTable.class);
   
	public static final String   TABLE_NAME          = "IMSPLEX";
    private static final String  VERSION             = "1.1";
    public static final String   SYSPLEX_ID          = "SYSPLEX_ID";
	public static final String   IMSPLEX_MBR_ID      = "IMSPLEX_MBR_ID";
	public static final String 	 UPDATED			 = "UPDATED";
	
	private static final String  SYSPLEX_TABLE_NAME  = SysplexTable.TABLE_NAME;
	private static final String INDEX_NAME = "INDEX_IMSPLEX_SYSPLEX";

	//TODO: NOTE TO DEV:
	//1. Refactor this class to match our current table names, follow class naming conventions, no Underscores
	//2. Consider making IMSPLX a constraint constraint so it can be used as a FK by other tables
	public OmImsplexTable(Datastore parentDatastore) throws DatastoreException {
 		super(parentDatastore, TABLE_NAME, VERSION, ImsplexResponseAttribute.MBR.toString()); // MBR is MbrName(e.g.OM1OM)
	}

	@Override
	public void createTables() throws OmDatastoreException {
		StringBuffer createSQL = new StringBuffer("CREATE TABLE ").append(this.tableName).append(" (")	
				.append(IMSPLEX_MBR_ID).append(" INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY, ") 	
				.append(ImsplexResponseAttribute.IMSPLX).append(" VARCHAR(255) NOT NULL, ")	 									
				.append(ImsplexResponseAttribute.MBR).append(" VARCHAR(255), ")										
				.append(ImsplexResponseAttribute.STYP).append(" VARCHAR(255), ") 											
				.append(ImsplexResponseAttribute.JOB).append(" VARCHAR(255), ") 									
				.append(ImsplexResponseAttribute.TYP).append(" VARCHAR(255), ")									
				.append(ImsplexResponseAttribute.IMSMBR).append(" VARCHAR(255), ")									
				.append(ImsplexResponseAttribute.VER).append(" VARCHAR(255), ")									
				.append(ImsplexResponseAttribute.STT).append(" VARCHAR(255), ")																		
				.append(ImsplexResponseAttribute.OS).append(" VARCHAR(255), ")									
				.append(ImsplexResponseAttribute.CC).append( " VARCHAR(255), ")	
				.append(SYSPLEX_ID).append(" INTEGER, ")
				.append(UPDATED).append(" TIMESTAMP DEFAULT CURRENT_TIMESTAMP, ")
				.append(" PRIMARY KEY (" ).append(IMSPLEX_MBR_ID).append("), ")
				.append(" FOREIGN KEY (").append(SYSPLEX_ID).append(") REFERENCES ").append(SYSPLEX_TABLE_NAME).append("(").append(SYSPLEX_ID).append(") ON DELETE SET NULL) ");

		StringBuffer index = new StringBuffer("CREATE INDEX ").append(INDEX_NAME).append(" ON ").append(this.tableName)
				.append(" (").append(ImsplexResponseAttribute.IMSPLX).append(",")
				.append(SYSPLEX_ID).append(",")
				.append(IMSPLEX_MBR_ID).append(")");
		try{
			execute(createSQL.toString());
		} catch(DatastoreException e) {
			OmDatastoreException omDatastoreException = new OmDatastoreException(e);
			omDatastoreException.setQuery("DROP TABLE " + this.tableName);
			throw omDatastoreException;
		}
		
		try {
            execute(index.toString());
		} catch (DatastoreException e) {
            OmDatastoreException omDatastoreException = new OmDatastoreException(e);
            omDatastoreException.setQuery(index.toString());
            throw omDatastoreException;
      }
	}

	@Override
	public int addImsplex(Imsplex imsplex,int sysplexId)  throws DatastoreException{
		Collection<Imsplex> imsplexMembers = new ArrayList<Imsplex>(1);
		imsplexMembers.add(imsplex);
		return addImsplex(imsplexMembers, sysplexId);
	}

	@Override
	public int addImsplex(Collection<Imsplex> imsplexMembers, int sysplexId) throws DatastoreException {//String IMSPLX, String MBR, String STYP, String JOB, String TYP, String IMSMBR, String  VER,
		Connection connection = null;
		PreparedStatement ps = null;
		int insertionSize=0;
		
		StringBuffer sb = new StringBuffer("INSERT INTO ")
		.append(this.tableName)
		.append(" ("+ ImsplexResponseAttribute.IMSPLX+","+ ImsplexResponseAttribute.MBR+","+  
		ImsplexResponseAttribute.STYP+","+ ImsplexResponseAttribute.JOB+","+ImsplexResponseAttribute.TYP+","+  
		ImsplexResponseAttribute.IMSMBR+","+ ImsplexResponseAttribute.VER+","+ ImsplexResponseAttribute.STT+","+ 
		ImsplexResponseAttribute.OS+","+ ImsplexResponseAttribute.CC+","+ SYSPLEX_ID+ ")").
		append(" VALUES (?,?,?,?,?,?,?,?,?,?,?)");
		
		try{
			int i = 0;
			connection = parentDatastore.getConnection();
			connection.setAutoCommit(false);
			ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);

			String member = null;
			String imsplex = null;
			for(Imsplex plexMember: imsplexMembers) {
				imsplex = plexMember.getProperty(ImsplexResponseAttribute.IMSPLX); 
				member = plexMember.getProperty(ImsplexResponseAttribute.MBR);
				
				ps.setString(1, plexMember.getProperty(ImsplexResponseAttribute.IMSPLX));
				ps.setString(2, plexMember.getProperty(ImsplexResponseAttribute.MBR));
				ps.setString(3, plexMember.getProperty(ImsplexResponseAttribute.STYP));
				ps.setString(4, plexMember.getProperty(ImsplexResponseAttribute.JOB));
				ps.setString(5, plexMember.getProperty(ImsplexResponseAttribute.TYP));
				ps.setString(6, plexMember.getProperty(ImsplexResponseAttribute.IMSMBR));
				ps.setString(7, plexMember.getProperty(ImsplexResponseAttribute.VER));
				ps.setString(8, plexMember.getProperty(ImsplexResponseAttribute.STT));
				ps.setString(9, plexMember.getProperty(ImsplexResponseAttribute.OS));
				ps.setString(10, plexMember.getProperty(ImsplexResponseAttribute.CC));
				ps.setInt(11, sysplexId);
				ps.addBatch();
				
				if((++i) % 1000 == 0) {
					insertionSize += ps.executeBatch().length;
					connection.commit();
					ps.clearBatch();
				}
			}
			 
			insertionSize += ps.executeBatch().length;
			connection.commit();
			ps.clearBatch();
		} catch(SQLException e) {
			try{
				logAndRollback(connection, e);
			} catch(DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
		} finally {
			close(ps);
			close(connection);
		}
		return insertionSize;
	}

//**************************************************************************************
// Get imsplex members methods
//**************************************************************************************	

	@Override
	public Collection<Imsplex> getImsPlexMembers(int sysplexId) throws OmDatastoreException {
		Collection<Imsplex> imsplexs = new ArrayList<Imsplex>();
		try {
			imsplexs = this.getImsPlexMembers(sysplexId, null, null);
		} catch (OmConnectionException e) {
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e) {
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
		return imsplexs;
	}
	
	@Override 
	public Collection<Imsplex> getImsPlexMembers(int sysplexId, String imsplexName) throws OmDatastoreException {
		Collection<Imsplex> imsplexs = new ArrayList<Imsplex>();
		try {
			imsplexs = this.getImsPlexMembers(sysplexId, imsplexName, null);
		} catch (OmConnectionException e) {
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e) {
			/** Will not be thrown because we pass null for the Om, so eat the error **/	
		}
		return imsplexs;
	}
	
	@Override
	public Collection<Imsplex> getImsPlexMembers(int sysplexId, String imsplexName, Om om) throws OmDatastoreException, OmException, OmConnectionException {
		Connection connection = null;
		PreparedStatement ps = null;
		ResultSet results = null;
		ArrayList<Imsplex> imsplexs = new ArrayList<Imsplex>();
		StringBuffer sb = null;
		Collection<Imsplex> imsplexMemberStatuses = null;

		try {
			//If the om is not null then query for the imsplex status
			if(om != null && !om.isInteractionModeCache()) {
				EnumSet<QueryImsPlex.StatusOptions> queryImsplexMemberStatusOptionsSet = EnumSet.allOf(QueryImsPlex.StatusOptions.class);
				QueryImsPlex.StatusOptions[] queryImsplexMemberStatusOptions = (QueryImsPlex.StatusOptions[]) queryImsplexMemberStatusOptionsSet.toArray(new QueryImsPlex.StatusOptions[queryImsplexMemberStatusOptionsSet.size()]);

				imsplexMemberStatuses = om.getImsplexService().getImsPlexMembersByStatus(queryImsplexMemberStatusOptions);

				if(imsplexMemberStatuses.size()>0){
					this.updateImsplexMemberStatus(imsplexMemberStatuses,sysplexId,imsplexName);
				}
			}

			connection = parentDatastore.getConnection();

			//Case: no route has been passed or the length is 0 but we need to check if an imsplexName has been passed
			if(imsplexName != null){
				sb = new StringBuffer("SELECT * FROM ")
				.append(this.tableName)
				.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
				.append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
				.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

				ps = connection.prepareStatement(sb.toString());
				ps.setInt(1, sysplexId);
				ps.setString(2, imsplexName);
			}else{
				//Case: All members given a sysplex and imsplex
				sb = new StringBuffer("SELECT * FROM ")
				.append(this.tableName)
				.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
				.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

				ps = connection.prepareStatement(sb.toString());
				ps.setInt(1, sysplexId);
			}

			results = ps.executeQuery();

			while (results.next()) {
				Imsplex imsplex = new Imsplex(results);
				imsplexs.add(imsplex);
			}

			//Execute process to cleanup the status column in the derby cache
			this.executeUpdateImsplexColumnAsynchronously(imsplexMemberStatuses, sysplexId, imsplexName);
		} catch(SQLException e) {
			try{
				logAndRollback(connection, e);
			} catch(DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				omDatastoreException.setEnvironmentId(sysplexId);
				throw omDatastoreException;
			}
		}finally {
			close(results);    // ResultSet
			close(ps);         // PreparedStatement
			close(connection); // Connection
		}
		return imsplexs;	
	}
	
	public Collection<Imsplex> getImsPlexMember(int sysplexId, QueryImsPlex.TypeOptions[] types) throws OmDatastoreException {
		Collection<Imsplex> imsplexMembers = new ArrayList<Imsplex>();
		
		try {
			imsplexMembers = getImsPlexMember(sysplexId, null, types, null); //new String[]{"*"}, 
		} catch(OmConnectionException e){
			/** Will not be thrown because we pass null for the Om, so eat the error **/			
		} catch(OmException e){
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
		
		return imsplexMembers;
	}
	
	public Collection<Imsplex> getImsPlexMember(int sysplexId, String imsplexName, QueryImsPlex.TypeOptions[] types) throws OmDatastoreException {
		Collection<Imsplex> imsplexMembers = new ArrayList<Imsplex>();
		
		try {
			imsplexMembers = getImsPlexMember(sysplexId, imsplexName, types, null); //new String[]{"*"}, 
		} catch (OmConnectionException e) { 
  			/** Will not be thrown because we pass null for the Om, so eat the error **/
  		  } catch (OmException e){ 
  			/** Will not be thrown because we pass null for the Om, so eat the error **/
  		  }
          
          return imsplexMembers;	
	}
	
	//SELECT * FROM IMSOM_IMSPLEX WHERE SYSPLEX_ID = 1  AND TYP = 'OM'  AND IMSPLX = CSLPLEX1  ORDER BY IMSMBR
	public Collection<Imsplex> getImsPlexMember(int sysplexId, String imsplexName, QueryImsPlex.TypeOptions[] types, Om om) throws OmDatastoreException, OmException, OmConnectionException {	
		Connection connection = null;
		PreparedStatement ps = null;
		ResultSet results = null;
		ArrayList<Imsplex> imsplexMembers = new ArrayList<Imsplex>();
		StringBuffer sb = null;
		Collection<Imsplex> imsplexMemberStatuses = null;

		try {
			//If the om is not null then query IMS for the imsplex status
			if(om != null && !om.isInteractionModeCache()){
				EnumSet<QueryImsPlex.StatusOptions> queryImsplexMemberStatusOptionSet = EnumSet.allOf(QueryImsPlex.StatusOptions.class);
				QueryImsPlex.StatusOptions[] queryImsplexMemberStatusOptions = queryImsplexMemberStatusOptionSet.toArray(new QueryImsPlex.StatusOptions[queryImsplexMemberStatusOptionSet.size()]);

				//Note: This error can happen when no imsplexMembers return with one of the requested statues "RC = 02000004, RSN =00001014 , RSM = CSLN055I, RSNTxt = At least one request completed with warning(s)"
				imsplexMemberStatuses = om.getImsplexService().getImsPlexMembersByStatus(queryImsplexMemberStatusOptions); //, imsSystemName

				//Insert the result of the status query into derby (if derby is empty nothing will happen)
				if(imsplexMemberStatuses.size()>0){
					updateImsplexMemberStatus(imsplexMemberStatuses, sysplexId, imsplexName);
				}
			}

			connection = parentDatastore.getConnection();

			//Case: no route has been passed or the length is 0 so we need to check if an imsplexName has been passed
//			if(imsSystemName == null || imsSystemName.length == 0){
				if(imsplexName != null){
					sb = new StringBuffer("SELECT * FROM ")
					.append(this.tableName)
					.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
					.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

					ps = connection.prepareStatement(sb.toString());
					ps.setInt(1, sysplexId);
					ps.setString(2,Arrays.asList(types).toString().replace("[", "").replace("]", ""));
					ps.setString(3, imsplexName);
				}else{
					sb = new StringBuffer("SELECT * FROM ")
					.append(this.tableName)
					.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
					.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

					ps = connection.prepareStatement(sb.toString());
					ps.setInt(1, sysplexId);
					ps.setString(2,Arrays.asList(types).toString().replace("[", "").replace("]", ""));
				}
				results = ps.executeQuery();

				while (results.next()) {
					Imsplex imsplex = new Imsplex(results);
					imsplexMembers.add(imsplex);
				}
//			}
//		else{ //Route had been passed and for each we route the command and concat the results
//				String sqlIn = this.sqlInGenerator(ImsplexResponseAttribute.MBR.toString(), imsSystemName);	
//				sb = new StringBuffer("SELECT * FROM ")
//				.append(this.tableName)
//				.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
//				.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
//				.append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
//				.append(sqlIn)
//				.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);
//
//				ps = connection.prepareStatement(sb.toString());
//				ps.setInt(1, sysplexId);
//				ps.setString(2, Arrays.asList(types).toString().replace("[", "").replace("]", ""));
//				ps.setString(3, imsplexName);
//
//
//				results = ps.executeQuery();
//
//				while (results.next()) {
//					Imsplex imsplex = new Imsplex(results);
//					imsplexMembers.add(imsplex);
//				}
//			}

			//Execute process to cleanup the status column in the derby cache
			this.executeUpdateImsplexColumnAsynchronously(imsplexMemberStatuses, sysplexId, imsplexName);
		} catch(SQLException e) {
			try {
				logAndRollback(connection, e);
			} catch(DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				omDatastoreException.setEnvironmentId(sysplexId);
				throw omDatastoreException;
			}
		} finally {
			close(results); 	// ResultSet
			close(ps);      	// PreparedStatement
			close(connection);	// Connection 
		}
		return imsplexMembers;
	}

	//SELECT * FROM IMSOM_IMSPLEX WHERE SYSPLEX_ID = 1  AND IMSPLX = 'CSLPLEX1'  AND TYP = 'IMS'  ORDER BY IMSMBR
	public Collection<Imsplex> getImsResources(int sysplexId, String imsplexName, String[] imsSystemName, Om om) throws OmDatastoreException, OmException, OmConnectionException {	
		Connection connection = null;
		PreparedStatement ps = null;
		ResultSet results = null;
		ArrayList<Imsplex> imsResources = new ArrayList<Imsplex>();
		StringBuffer sb = null;
		try {
			connection = parentDatastore.getConnection();

			//Case: no route has been passed or the length is 0 but so we need to check if an impslexname has been passed.
			if(imsSystemName == null || imsSystemName.length == 0){
				if(imsplexName != null){
					sb = new StringBuffer("SELECT * FROM ")
					.append(this.tableName)
					.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
					.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

					ps = connection.prepareStatement(sb.toString());
					ps.setInt(1, sysplexId);
					ps.setString(2, imsplexName); 
					ps.setString(3,QueryImsPlex.TypeOptions.IMS.toString());
				}else{  
					sb = new StringBuffer("SELECT * FROM ")
					.append(this.tableName)
					.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
					.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

					ps = connection.prepareStatement(sb.toString());
					ps.setInt(1, sysplexId);
					ps.setString(2,QueryImsPlex.TypeOptions.IMS.toString());
				}
				
				results = ps.executeQuery();
				while (results.next()) {
					Imsplex imsplex = new Imsplex(results);
					imsResources.add(imsplex);
				}
			}else{ //Route has been passed and for each we route the command and concat the results
				String sqlIn = this.sqlInGenerator(ImsplexResponseAttribute.MBR.toString(), imsSystemName);
				sb = new StringBuffer("SELECT * FROM ")
				.append(this.tableName)
				.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
				.append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
				.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
				.append(sqlIn)
				.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

				ps = connection.prepareStatement(sb.toString());
				ps.setInt(1, sysplexId);						
				ps.setString(2, imsplexName); 
				ps.setString(3, QueryImsPlex.TypeOptions.IMS.toString());

				results = ps.executeQuery();
				while (results.next()) {
					Imsplex imsplex = new Imsplex(results);
					imsResources.add(imsplex);
				}
			}
		} catch(SQLException e) {
			try {
				logAndRollback(connection, e);
			} catch(DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
		} finally {
			close(results); 	// ResultSet
			close(ps);      	// PreparedStatement
			close(connection);	// Connection 
		}
		return imsResources;
	}

	public Collection<Imsplex> getImsPlexMemberVersion(int sysplexId, String imsplexName, String[] imsSystemName, QueryImsPlex.TypeOptions[] types, Om om) throws OmDatastoreException, OmException, OmConnectionException {	
		Connection connection = null;
		PreparedStatement ps = null;
		ResultSet results = null;
		ArrayList<Imsplex> imsplexMembers = new ArrayList<Imsplex>();
		StringBuffer sb = null;
		try {
			connection = parentDatastore.getConnection();

           	//Case: no route has been passed or the length is 0 but so we need to check if an impslexname has been passed.
			if(imsSystemName == null || imsSystemName.length == 0){
				if(imsplexName != null){
					sb = new StringBuffer("SELECT * FROM ")
					.append(this.tableName)
					.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
					.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

					ps = connection.prepareStatement(sb.toString());
					ps.setInt(1, sysplexId);
					ps.setString(2, imsplexName);
					ps.setString(3,Arrays.asList(types).toString().replace("[", "").replace("]", ""));
				}else{  
					sb = new StringBuffer("SELECT * FROM ")
					.append(this.tableName)
					.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
					.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
					.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

					ps = connection.prepareStatement(sb.toString());
					ps.setInt(1, sysplexId);
					ps.setString(2,Arrays.asList(types).toString().replace("[", "").replace("]", ""));
				}
				results = ps.executeQuery();
				while (results.next()) {
					Imsplex imsplex = new Imsplex(results);
					imsplexMembers.add(imsplex);
				}
			}else{ //Route has been passed and for each we route the command and concat the results
				String sqlIn = this.sqlInGenerator(ImsplexResponseAttribute.MBR.toString(), imsSystemName);
				sb = new StringBuffer("SELECT * FROM ")
				.append(this.tableName)
				.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
				.append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
				.append(" AND ").append(ImsplexResponseAttribute.TYP).append(" = ? ")
				.append(sqlIn)
				.append(" ORDER BY ").append(ImsplexResponseAttribute.IMSMBR);

				ps = connection.prepareStatement(sb.toString());
				ps.setInt(1, sysplexId);
				ps.setString(2, imsplexName);
				ps.setString(3, Arrays.asList(types).toString().replace("[", "").replace("]", ""));

				results = ps.executeQuery();
				while (results.next()) {
					Imsplex imsplex = new Imsplex(results);
					imsplexMembers.add(imsplex);
				}
			}
		} catch(SQLException e) {
			try {
				logAndRollback(connection, e);
			} catch(DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
		} finally {
			close(results); 	// ResultSet
			close(ps);      	// PreparedStatement
			close(connection);	// Connection 
		}
		return imsplexMembers;
	}

//*******************************************************************************************
// Update IMSPlex members functions
//*******************************************************************************************	
	/**
	 * Method allows updating the ImsplexMembers status (LSTT) in the cache with the status given a collection of ImsplexMembers
	 * containing LSTT, sysplexId and the imsplexId. This is often useful in combination after discovery has been performed where returning
	 * a list of ImsplexMembers could require a status update to be inserted into the cache before returning the collection of ImsplexMembers
	 * @param ImsplexMembers Collection of ImsplexMembers with updated status. At minimum the object should have in it
	 * LSTT,Imsplex and MBR. 
	 * @param sysplexId
	 * @param imsplexId
	 * @return an array of update counts containing one element for each command in the batch. The elements of the 
	 * array are ordered according to the order in which commands were added to the batch. 
	 * @throws DatastoreException
	 */
	public int[] updateImsplexMemberStatus(Collection<Imsplex> imsplexMembers, int sysplexId, String imsplexName) throws OmDatastoreException{
		
		StringBuffer sb = new StringBuffer("UPDATE ")
        .append(this.tableName)
        .append(" SET ").append(ImsplexResponseAttribute.STT).append(" = ? ")
        .append(" WHERE ").append(ImsplexResponseAttribute.IMSMBR).append(" = ? ")
        .append(" AND ").append(ImsplexResponseAttribute.MBR).append(" = ? ")
        .append(" AND ").append(SYSPLEX_ID).append(" = ? ")
        .append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ");
        
        Connection connection = null;
        PreparedStatement ps = null;
        int[] result = new int[0];
        ArrayList<int[]> results = new ArrayList<int[]>();
        
        try {
        	connection = parentDatastore.getConnection();
        	connection.setAutoCommit(false);
            ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
            int i =0;
            
            for(Imsplex imsplex: imsplexMembers){
            	ps.setString(1, imsplex.getProperty(ImsplexResponseAttribute.STT));
                ps.setString(2, imsplex.getProperty(ImsplexResponseAttribute.IMSMBR));
                ps.setString(3, imsplex.getProperty(ImsplexResponseAttribute.MBR));
                ps.setInt(4, sysplexId);
                ps.setString(5,imsplexName);
                ps.addBatch();
                if ((++i) % 1000 == 0) {
                	results.add(ps.executeBatch());
                	connection.commit();
                	ps.clearBatch();
                }
            }
            results.add(ps.executeBatch());
            connection.commit();
            
        } catch(SQLException e) {
        	try {
				logAndRollback(connection, e);
			} catch (DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
        } finally {
        	close(ps);         
        	close(connection); 
        }
        
        for(int i = 0; i < results.size();i++){
        	result = ArrayUtils.mergeArrays(result, results.get(i));
        }
        
        return result;
	}
	
	/**
	 * This method will update the column (IMS Attribute) with a specific value for a given collection of imsplexs. This is helpful when 
	 * wanting to null out or override certain values such as STT (status). Operates similar to {@link #updateimsplexColumn(imsplexResponseAttribute, String, String, int, int)}
	 * but will do so a bit more efficiently only targeting the imsplexs in the collection of imsplexs. 
	 * @param imsplexs
	 * @param ImsplexResponseAttribute
	 * @param value
	 * @param sysplexId
	 * @param imsplexId
	 * @return
	 * @throws DatastoreException
	 */
	@Override
	public int updateImsplexColumn(Collection<Imsplex> imsplexs, ImsplexResponseAttribute imsplexResponseAttribute, String value, int sysplexId, String imsplexName) throws OmDatastoreException{
	    StringBuffer sb = new StringBuffer("UPDATE ")
        .append(this.tableName)
        .append(" SET ").append(imsplexResponseAttribute).append(" = ? ")
        .append(" WHERE ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ")
        .append(" AND ").append(ImsplexResponseAttribute.MBR).append(" = ? ")
        .append(" AND ").append(SYSPLEX_ID).append(" = ? ")
        .append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ");
        
        Connection connection = null;
        PreparedStatement ps = null;
        int updateSize = 0;
        ArrayList<int[]> results = new ArrayList<int[]>();
        
        try {
        	connection = parentDatastore.getConnection();
        	connection.setAutoCommit(false);
            ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
            int i =0;
            
            for(Imsplex imsplex: imsplexs){
            	ps.setString(1, value);
                ps.setString(2, imsplex.getProperty(ImsplexResponseAttribute.IMSPLX));
                ps.setString(3, imsplex.getProperty(ImsplexResponseAttribute.MBR));
                ps.setInt(4, sysplexId);
                ps.setString(5,imsplexName);
                ps.addBatch();
                if ((++i) % 1000 == 0) {
                	results.add(ps.executeBatch());
                	connection.commit();
                	ps.clearBatch();
                }
            }
            updateSize = ps.executeBatch().length;
            connection.commit();
            
        } catch(SQLException e) {
        	try {
				logAndRollback(connection, e);
			} catch (DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
        } finally {
        	close(ps);         
        	close(connection); 
        }
        
        return updateSize;
	}	

	/**
	 * This will update an entire column given a sysplex, imsplex, imsSystemName (mbr name) and the value for that column. This can be an expensive
	 * task since there can be many rows given the above values. Its more efficient to use a method that can update only needed rows
	 * see {@link #updateimsplexs(Collection<imsplex> imsplexs, imsplexResponseAttribute imsplexResponseAttribute, String value, int sysplexId, int imsplexId) }
	 * @param imsplexResponseAttribute
	 * @param value
	 * @param imsSystemName
	 * @param sysplexId
	 * @param imsplexId
	 * @return
	 * @throws DatastoreException
	 */
	@Override
	public int updateImsplexColumn(ImsplexResponseAttribute imsplexResponseAttribute, String value, String imsSystemName, int sysplexId, String imsplexName) throws OmDatastoreException{
		StringBuffer sb = new StringBuffer("UPDATE ")
        .append(this.tableName)
        .append(" SET ").append(imsplexResponseAttribute).append(" = ? ")
        .append(" WHERE ").append(ImsplexResponseAttribute.MBR).append(" = ? ")
        .append(" AND ").append(SYSPLEX_ID).append(" = ? ")
        .append(" AND ").append(ImsplexResponseAttribute.IMSPLX).append(" = ? ");
		
		 	Connection connection = null;
	        PreparedStatement ps = null;
	        int result = 0;

	        try {
	        	connection = parentDatastore.getConnection();
	            ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
	            ps.setString(1, value);
	            ps.setString(2, imsSystemName);
	            ps.setInt(3, sysplexId);
	            ps.setString(4, imsplexName);
	           
	            ps.executeUpdate();
	            connection.commit();
	        } catch(SQLException e) {
	        	try {
					logAndRollback(connection, e);
				} catch (DatastoreException e1) {
					OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
					omDatastoreException.setQuery(sb.toString());
					throw omDatastoreException;
				}
	        } finally {
	        	close(ps);         // PreparedStatement
	        	close(connection); // Connection
	        }
	        return result; //TODO: this always returns zero, we need to fix this
	}
	
	public Collection<String> getDistinctColumn(int sysplexId,String imsplexName, ImsplexResponseAttribute imsplexResponseAttribute) throws OmDatastoreException{
		return this.getDistinctColumn(sysplexId, imsplexName, imsplexResponseAttribute.toString());
	}
	
//	public void autoConfigureResourceMetatData(int sysplex, String imsplex, String mbrName) throws OmDatastoreException {
//		imsplex = "CSL" + imsplex;
//		this.autoConfigureResourceMetaData(sysplex, imsplex, mbrName);
//	}
      
//**************************************************************************************
// asynchronous clean up methods
//**************************************************************************************
	/**
	 * Executes a callable to clean up the Imsplex status column, see {link {@link updateImsplexColumnAsynchronously}
	 * @param ImsplexStatuses
	 * @param sysplexId
	 * @param imsplexId
	 * @return
	 */
	private int executeUpdateImsplexColumnAsynchronously(Collection<Imsplex> imsplexStatuses, int sysplexId, String imsplexName){
		int result = 0;
		ExecutorService service =  Executors.newSingleThreadExecutor();
		updateImsplexColumnAsynchronously upImsplexsAssychronously = new updateImsplexColumnAsynchronously(imsplexStatuses,sysplexId,imsplexName);
		Future<Integer> future = service.submit(upImsplexsAssychronously);
		try {
			result =  future.get();
		} catch (InterruptedException e) {
			//TODO: Do anything here?
		} catch (ExecutionException e) {
			//TODO: Do anything here?
		}

		return result;
	}
	/**
	 * <pre>
	 * Class will create a callable to run in the background for a non-blocking call to {@link ImsImsplexTable#updateImsplexColumn(Collection, ImsplexResponseAttribute, String, int, int)}
	 *
	 * Usage:
	 *  ExecutorService service =  Executors.newSingleThreadExecutor();
	 *  updateImsplexColumnAsynchronously upImsplexsAssychronously = new updateImsplexColumnAsynchronously(ImsplexStatuses,sysplexId,imsplexId);
	 *  Future<Integer> future = service.submit(upImsplexsAssychronously);
	 *  try {
	 *  	Integer result = future.get();
	 *  } catch (InterruptedException e) {
	 *  } catch (ExecutionException e) {} 
	 * 
	 * @author ddimatos
	 *</pre>
	 */
	private class updateImsplexColumnAsynchronously implements Callable<Integer> {
		private Collection<Imsplex> ImsplexStatuses ;
		private int sysplexId;
		private String imsplexName;

		// Null out the statuses that were set, we want to keep the status column null after use
		private updateImsplexColumnAsynchronously(Collection<Imsplex> ImsplexStatuses, int sysplexId, String imsplexName) {
			this.ImsplexStatuses = ImsplexStatuses;
			this.sysplexId = sysplexId;
			this.imsplexName = imsplexName;
		}

		@Override
		public Integer call() throws OmDatastoreException  {
			//My guess is this is thread safe because Derby will not allow a read during an update
			return new Integer (updateImsplexColumn(ImsplexStatuses,ImsplexResponseAttribute.STT,null,sysplexId,imsplexName));
		}
	}
	
	
	 public Collection<String> getImsplexes(int sysplexId) throws OmDatastoreException {

	    	Collection<String>imsplexNames = new ArrayList<String>();
	    	// Will return CSLPLEX1, CSLPLEX2,... attached to SYSPLEX ID = 1
	    	imsplexNames  = getDistinctColumn(sysplexId, null, ImsplexResponseAttribute.IMSPLX);
	    		 
	    	return imsplexNames;
	    }
}
