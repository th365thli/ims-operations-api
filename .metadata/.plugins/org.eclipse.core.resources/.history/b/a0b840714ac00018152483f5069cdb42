/*********************************************************************************
 * Licensed Materials - Property of IBM
 * 5655-TAC
 * (C) Copyright IBM Corp. 2013 All Rights Reserved. 
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with 
 * IBM Corp.               
 *********************************************************************************/

package com.ibm.ims.ea.om.datastore;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.ibm.im.ac.datastore.Datastore;
import com.ibm.im.ac.datastore.DatastoreException;
import com.ibm.im.ac.datastore.impl.SysplexTable;
import com.ibm.ims.ea.om.cmd.v14.query.rtc.QueryRtc;
import com.ibm.ims.ea.om.common.exception.OmConnectionException;
import com.ibm.ims.ea.om.common.exception.OmDatastoreException;
import com.ibm.ims.ea.om.common.exception.OmException;
import com.ibm.ims.ea.om.common.services.Om;
import com.ibm.ims.ea.om.rtc.RoutingCode;
import com.ibm.ims.ea.om.rtc.RoutingCode.RtcResponseAttribute;
import com.ibm.ims.ea.om.tran.Transaction.TransactionResponseAttribute;

public class ImsRoutingCodeTable extends AbstractImsBaseDatastore{
    private static final String VERSION     = "1.1";
    private static final String COMMA       = " , ";
    public static final String TABLE_NAME   = "ROUTING_CODE";
	public static final String SYSPLEX_ID 	= "SYSPLEX_ID";
	public static final String RTC_ID 		= "RTC_ID";
	public static final String TIMESTAMP	= "TIMESTAMP";
	public static final String UPDATED		= "UPDATED";
	
	private static final String SYSPLEX_TABLE_NAME = SysplexTable.TABLE_NAME;
	private static final String INDEX_NAME = "INDEX_RTC_MBR_SYSPLEX_IMSPLEX";
	//private  static final String UPDATE_EDIT_DATE_TRIGGER = "UPDATE_ROUTING_CODE_DATE_TRIGGER";
	
	protected ImsRoutingCodeTable(Datastore parentDatastore) throws DatastoreException {
		super(parentDatastore, TABLE_NAME, VERSION, RtcResponseAttribute.MBR.toString());
	}

	@Override
	public void createTables() throws DatastoreException { 
		StringBuffer createSQL = new StringBuffer("CREATE TABLE ").append(this.tableName).append(" (")
				.append(RTC_ID).append(" INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY, ")
				.append(RtcResponseAttribute.CC).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.CCTXT).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.DFNT).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.IMSID).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.INQ).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.LSTT).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.MBR).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.MDLN).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.MDLT).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.PGM).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.REG).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.REPO).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.RINQ).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.RPGM).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.RTC).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.RTMCR).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.RTMUP).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.TMAC).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.TMCR).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.TMIM).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.TMUP).append(" VARCHAR(255), ")
				.append(RtcResponseAttribute.WRK).append(" VARCHAR(255), ")
				.append(SYSPLEX_ID).append(" INTEGER, ")
				.append(UPDATED).append(" TIMESTAMP DEFAULT CURRENT_TIMESTAMP, ")
				.append(IMSPLX).append(" VARCHAR(255) NOT NULL, ")
		 		.append(" FOREIGN KEY (").append(SYSPLEX_ID).append(") REFERENCES ").append(SYSPLEX_TABLE_NAME).append("(").append(SYSPLEX_ID).append(") ON DELETE SET NULL)");

            // Don't delete this is a problem with this trigger causing duplicates on update.
            //			StringBuffer trigger = new StringBuffer("CREATE TRIGGER ").append(UPDATE_EDIT_DATE_TRIGGER)
            //				.append(" AFTER UPDATE  OF LSTT ON ").append(this.tableName)
            //				.append(" REFERENCING OLD AS MODIFIEDROW FOR EACH  ROW ")
            //				.append(" UPDATE " ).append(this.tableName).append(" SET ")
            //				.append(this.tableName).append(".").append(UPDATED).append(" = ").append(" CURRENT_TIMESTAMP ")
            //				.append(" WHERE ").append(RTC_ID).append(" = ").append(" MODIFIEDROW").append(".").append(RTC_ID);
		
	         StringBuffer index = new StringBuffer("CREATE INDEX ").append(INDEX_NAME).append(" ON ").append(this.tableName)
	                    .append(" (").append(RtcResponseAttribute.RTC).append(",")
	                    .append(RtcResponseAttribute.MBR).append(",")
	                    .append(SYSPLEX_ID).append(",")
	                    .append(IMSPLX).append(")");
	         
		try {
			execute(createSQL.toString());
		} catch (DatastoreException e) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e);
				omDatastoreException.setQuery(createSQL.toString());
				throw omDatastoreException;
		}
		
		/*		try {
			execute(trigger.toString());
		} catch (DatastoreException e) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e);
				omDatastoreException.setQuery(trigger.toString());
				throw omDatastoreException;
		}*/
		
	    try {
              execute(index.toString());
        } catch (DatastoreException e) {
              OmDatastoreException omDatastoreException = new OmDatastoreException(e);
              omDatastoreException.setQuery(index.toString());
              throw omDatastoreException;
        }
	}

	public int  addImsRoutingCode(Collection<RoutingCode> routingCodes,int sysplexId, String imsplexName)  throws OmDatastoreException{
		Connection connection 	= null;
        PreparedStatement ps 	= null;
        int insertionSize=0;
        
        StringBuffer sb = new StringBuffer("INSERT INTO ")
    	        .append(this.tableName)
    	        .append(" (")
    	        .append(RtcResponseAttribute.CC).append(COMMA)
    	        .append(RtcResponseAttribute.CCTXT).append(COMMA)
    	        .append(RtcResponseAttribute.DFNT).append(COMMA)
    	        .append(RtcResponseAttribute.IMSID).append(COMMA)
    	        .append(RtcResponseAttribute.INQ).append(COMMA)
    	        .append(RtcResponseAttribute.LSTT).append(COMMA)
    	        .append(RtcResponseAttribute.MBR).append(COMMA)
    	        .append(RtcResponseAttribute.MDLN).append(COMMA)
    	        .append(RtcResponseAttribute.MDLT).append(COMMA)
    	        .append(RtcResponseAttribute.PGM).append(COMMA)
    	        .append(RtcResponseAttribute.REG).append(COMMA)
    	        .append(RtcResponseAttribute.REPO).append(COMMA)
    	        .append(RtcResponseAttribute.RINQ).append(COMMA)
    	        .append(RtcResponseAttribute.RPGM).append(COMMA)
    	        .append(RtcResponseAttribute.RTC).append(COMMA)
    	        .append(RtcResponseAttribute.RTMCR).append(COMMA)
    	        .append(RtcResponseAttribute.RTMUP).append(COMMA)
    	        .append(RtcResponseAttribute.TMAC).append(COMMA)
    	        .append(RtcResponseAttribute.TMCR).append(COMMA)
    	        .append(RtcResponseAttribute.TMIM).append(COMMA)
    	        .append(RtcResponseAttribute.TMUP).append(COMMA)
    	        .append(RtcResponseAttribute.WRK).append(COMMA)
    	        .append(SYSPLEX_ID).append(COMMA)
    	        .append(IMSPLX)
    	        .append(")")
    	        .append(" VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
        
		try {
		    int i = 0;
            connection = parentDatastore.getConnection();
            connection.setAutoCommit(false);
            ps = connection.prepareStatement(sb.toString(),Statement.RETURN_GENERATED_KEYS);
            
			for (RoutingCode rtc : routingCodes) {
				ps.setString(1, rtc.getProperty(RtcResponseAttribute.CC));
				ps.setString(2, rtc.getProperty(RtcResponseAttribute.CCTXT));
				ps.setString(3, rtc.getProperty(RtcResponseAttribute.DFNT));
				ps.setString(4, rtc.getProperty(RtcResponseAttribute.IMSID));
				ps.setString(5, rtc.getProperty(RtcResponseAttribute.INQ));
				ps.setString(6,null); // //We don't want to store the status at this point, let getPrograms manage status (7, rtc.getProperty(RtcResponseAttribute.LSTT));
				ps.setString(7, rtc.getProperty(RtcResponseAttribute.MBR));
				ps.setString(8, rtc.getProperty(RtcResponseAttribute.MDLN));
				ps.setString(9, rtc.getProperty(RtcResponseAttribute.MDLT));
				ps.setString(10, rtc.getProperty(RtcResponseAttribute.PGM));
				ps.setString(11, rtc.getProperty(RtcResponseAttribute.REG));
				ps.setString(12, rtc.getProperty(RtcResponseAttribute.REPO));
				ps.setString(13, rtc.getProperty(RtcResponseAttribute.RINQ));
				ps.setString(14, rtc.getProperty(RtcResponseAttribute.RPGM));
				ps.setString(15, rtc.getProperty(RtcResponseAttribute.RTC));
				ps.setString(16, rtc.getProperty(RtcResponseAttribute.RTMCR));
				ps.setString(17, rtc.getProperty(RtcResponseAttribute.RTMUP));
				ps.setString(18, rtc.getProperty(RtcResponseAttribute.TMAC));
				ps.setString(19, rtc.getProperty(RtcResponseAttribute.TMCR));
				ps.setString(20, rtc.getProperty(RtcResponseAttribute.TMIM));
				ps.setString(21, rtc.getProperty(RtcResponseAttribute.TMUP));
				ps.setString(22, rtc.getProperty(RtcResponseAttribute.WRK));
				ps.setInt(23, sysplexId);
				ps.setString(24, imsplexName);
				ps.addBatch();
				
				
				if ((++i) % 1000 == 0) {
					insertionSize += ps.executeBatch().length;
					connection.commit();
					ps.clearBatch();
				}
			}
			
			insertionSize += ps.executeBatch().length;
			connection.commit();
			ps.clearBatch();
			
		} catch (SQLException e) {
        	try {
				logAndRollback(connection, e);
			} catch (DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
		} finally {
			close(ps); 
			close(connection);
		}
		return insertionSize;
	}

//*******************************************************************************************
// Update IMS Routing Code functions
//*******************************************************************************************
	
	/**
	 * Method will update the cached routing codes with the status that is passed in the collection of routing codes. 
	 * This updates the LSTT column ONLY {@link RtcResponseAttribute#LSTT} for each routing code. This differs from
	 * {@link #updateRoutingCodeColumn(Collection, RtcResponseAttribute, String, int, String)} in that only LSTT
	 * is updated versus having the entire column upated for any chosen value for the collection. 
	 * @param routingCodes
	 * @param sysplexId
	 * @param imsplexName
	 * @return
	 * @throws OmDatastoreException
	 */
	public int updateRoutingCodeStatus(Collection<RoutingCode> routingCodes, int sysplexId, String imsplexName) throws OmDatastoreException{
        Connection connection = null;
        PreparedStatement ps = null;
		int insertionSize=0;
		
		StringBuffer  sb = new StringBuffer("UPDATE ")
		.append(this.tableName)
		.append(" SET ").append(RtcResponseAttribute.LSTT).append(" = ? ")
        .append(" WHERE ").append(RtcResponseAttribute.RTC).append(" = ? ")
        .append(" AND ").append(RtcResponseAttribute.MBR).append(" = ? ")
        .append(" AND ").append(SYSPLEX_ID).append(" = ? ")
        .append(" AND ").append(IMSPLX).append(" = ? ");
        
        try {
        	connection = parentDatastore.getConnection();
        	connection.setAutoCommit(false);
            ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
            int i =0;
            
            for(RoutingCode rtc: routingCodes){
            	ps.setString(1, rtc.getProperty(RtcResponseAttribute.LSTT));
                ps.setString(2, rtc.getProperty(RtcResponseAttribute.RTC));
                ps.setString(3, rtc.getProperty(RtcResponseAttribute.MBR));
                ps.setInt(4, sysplexId);
                ps.setString(5,imsplexName);
                ps.addBatch();
                
				if ((++i) % 1000 == 0) {
					insertionSize += ps.executeBatch().length;
					connection.commit();
					ps.clearBatch();
				}
            }
            
			insertionSize += ps.executeBatch().length;
			connection.commit();
			ps.clearBatch();
			
        } catch(SQLException e) {
        	try {
				logAndRollback(connection, e);
			} catch (DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
        } finally {
        	close(ps);        
        	close(connection);
        }
        
        return insertionSize;
	}
	
	/**
	 * This method will change a particular column/attribute for each routing code in the collection for any defined value 
	 * you choose. This is often helpful if you want to NULL out a column value after and update such as STATUS/LSTT. 
	 * @param routingCodes
	 * @param column
	 * @param value
	 * @param sysplexId
	 * @param imsplexName
	 * @return
	 * @throws OmDatastoreException
	 */
	public int updateRoutingCodeColumn(Collection<RoutingCode> routingCodes, RtcResponseAttribute column, String value, int sysplexId, String imsplexName) throws OmDatastoreException{
	    StringBuffer sb = new StringBuffer("UPDATE ")
        .append(this.tableName)
        .append(" SET ").append(column).append(" = ? ")
        .append(" WHERE ").append(RtcResponseAttribute.RTC).append(" = ? ")
        .append(" AND ").append(RtcResponseAttribute.MBR).append(" = ? ")
        .append(" AND ").append(SYSPLEX_ID).append(" = ? ")
        .append(" AND ").append(IMSPLX).append(" = ? ");
		
        Connection connection = null;
        PreparedStatement ps = null;
        int updateSize=0;
        
        try {
        	connection = parentDatastore.getConnection();
        	connection.setAutoCommit(false);
            ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
            int i =0;
            
            for(RoutingCode rtc: routingCodes){
            	ps.setString(1, value);
                ps.setString(2, rtc.getProperty(RtcResponseAttribute.RTC));
                ps.setString(3, rtc.getProperty(RtcResponseAttribute.MBR));
                ps.setInt(4, sysplexId);
                ps.setString(5,imsplexName);
                ps.addBatch();
                
				if ((++i) % 1000 == 0) {
					updateSize += ps.executeBatch().length;
					connection.commit();
					ps.clearBatch();
				}
            }
            
			updateSize += ps.executeBatch().length;
			connection.commit();
			ps.clearBatch();
            
        } catch(SQLException e) {
        	try {
				logAndRollback(connection, e);
			} catch (DatastoreException e1) {
				OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
				omDatastoreException.setQuery(sb.toString());
				throw omDatastoreException;
			}
        } finally {
        	close(ps);         
        	close(connection); 
        }
        
        return updateSize;
	}
	
	/**
	 * This method will allow you to insert a value into an entire column similar to {@link #updateRoutingCodeColumn(Collection, RtcResponseAttribute, String, int, String)}
	 * only that in this method its not going to be for any specific routing code but instead all of them. This is helpful
	 * if you want to NULL out a column for the entire imsplex but it is an expensive action to take. 
	 * @param Column
	 * @param value
	 * @param systemId
	 * @param sysplexId
	 * @param imsplexName
	 * @return
	 * @throws DatastoreException
	 */
	public int updateRoutingCodeColumn(RtcResponseAttribute column, String value, int sysplexId, String imsplexName) throws OmDatastoreException{
		StringBuffer sb = new StringBuffer("UPDATE ")
        .append(this.tableName)
        .append(" SET ").append(column).append(" = ? ")
        .append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
        .append(" AND ").append(IMSPLX).append(" = ? ");
		
		 Connection connection = null;
	        PreparedStatement ps = null;
	        int result = 0;

	        try {
	        	connection = parentDatastore.getConnection();
	            ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
	            ps.setString(1, value);
	            ps.setInt(2, sysplexId);
	            ps.setString(3, imsplexName);
	           
	            result = ps.executeUpdate();
	            connection.commit();
	            
	        } catch(SQLException e) {
	        	try {
					logAndRollback(connection, e);
				} catch (DatastoreException e1) {
					OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
					omDatastoreException.setQuery(sb.toString());
					throw omDatastoreException;
				}
	        } finally {
	        	close(ps);         
	        	close(connection); 
	        }
	        return result;
	}
	
	
	/**
	 * This method will allow you to insert a value into an entire column similar to {@link #updateRoutingCodeColumn(Collection, RtcResponseAttribute, String, int, String)}
	 * only that in this method its not going to be for any specific routing code but instead all of them. This is helpful
	 * if you want to NULL out a column for an IMS. 
	 * @param column
	 * @param value
	 * @param systemId
	 * @param sysplexId
	 * @param imsplexName
	 * @return
	 * @throws OmDatastoreException
	 */
	public int updateRoutingCodeColumn(RtcResponseAttribute column, String value,String systemId, int sysplexId, String imsplexName) throws OmDatastoreException{
		StringBuffer sb = new StringBuffer("UPDATE ")
        .append(this.tableName)
        .append(" SET ").append(column).append(" = ? ")
        .append(" WHERE ").append(RtcResponseAttribute.MBR).append(" = ? ")
        .append(" AND ").append(SYSPLEX_ID).append(" = ? ")
        .append(" AND ").append(IMSPLX).append(" = ? ");
		
		 Connection connection = null;
	        PreparedStatement ps = null;
	        int result = 0;

	        try {
	        	connection = parentDatastore.getConnection();
	            ps = connection.prepareStatement(sb.toString(), Statement.RETURN_GENERATED_KEYS);
	            ps.setString(1, value);
	            ps.setString(2, systemId);
	            ps.setInt(3, sysplexId);
	            ps.setString(4, imsplexName);
	           
	            result = ps.executeUpdate();
	            connection.commit();
	            
	        } catch(SQLException e) {
	        	try {
					logAndRollback(connection, e);
				} catch (DatastoreException e1) {
					OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
					omDatastoreException.setQuery(sb.toString());
					throw omDatastoreException;
				}
	        } finally {
	        	close(ps);         
	        	close(connection); 
	        }
	        return result;
	}

	public int updateRoutingcode(Collection<RoutingCode> routingcodes , int sysplexId, String imsplexName) throws OmDatastoreException{
		
		Connection connection 	= null;
		PreparedStatement ps 	= null;
		int insertionSize=0;
						
		StringBuffer  sb = new StringBuffer("UPDATE ")
		.append(this.tableName).append(" SET ")
		.append(RtcResponseAttribute.CC).append(" = ? , ")
		.append(RtcResponseAttribute.CCTXT).append(" = ? , ")
		.append(RtcResponseAttribute.DFNT).append(" = ? , ")
		.append(RtcResponseAttribute.IMSID).append(" = ? , ")
		.append(RtcResponseAttribute.INQ).append(" = ? , ")
		.append(RtcResponseAttribute.LSTT).append(" = ? , ")
		.append(RtcResponseAttribute.MBR).append(" = ? , ")
		.append(RtcResponseAttribute.MDLN).append(" = ? , ")
		.append(RtcResponseAttribute.MDLT).append(" = ? , ")
		.append(RtcResponseAttribute.PGM).append(" = ? , ")
		.append(RtcResponseAttribute.REG).append(" = ? , ")
		.append(RtcResponseAttribute.REPO).append(" = ? , ")
		.append(RtcResponseAttribute.RINQ).append(" = ? , ")
		.append(RtcResponseAttribute.RPGM).append(" = ? , ")
		.append(RtcResponseAttribute.RTC).append(" = ? , ")
		.append(RtcResponseAttribute.RTMCR).append(" = ? , ")
		.append(RtcResponseAttribute.RTMUP).append(" = ? , ")
		.append(RtcResponseAttribute.TMAC).append(" = ? , ")
		.append(RtcResponseAttribute.TMCR).append(" = ? , ")
		.append(RtcResponseAttribute.TMIM).append(" = ? , ")
		.append(RtcResponseAttribute.TMUP).append(" = ? , ")
		.append(RtcResponseAttribute.WRK).append(" = ?  ")
		.append(" WHERE ").append(RtcResponseAttribute.RTC).append(" = ? ")
        .append(" AND ").append(RtcResponseAttribute.MBR).append(" = ? ")
		.append(" AND ").append(SYSPLEX_ID).append(" = ? ")
		.append(" AND ").append(IMSPLX).append(" = ? ");
		
		try{
			int i = 0;
	        connection = parentDatastore.getConnection();
	        connection.setAutoCommit(false);
	        ps = connection.prepareStatement(sb.toString(),Statement.RETURN_GENERATED_KEYS);
	           
			for(RoutingCode routingcode: routingcodes){
				ps.setString(1, routingcode.getProperty(RtcResponseAttribute.CC));
				ps.setString(2, routingcode.getProperty(RtcResponseAttribute.CCTXT));
				ps.setString(3, routingcode.getProperty(RtcResponseAttribute.DFNT));
				ps.setString(4, routingcode.getProperty(RtcResponseAttribute.IMSID));
				ps.setString(5, routingcode.getProperty(RtcResponseAttribute.INQ));
				ps.setString(6, routingcode.getProperty(RtcResponseAttribute.LSTT));
				ps.setString(7, routingcode.getProperty(RtcResponseAttribute.MBR));
				ps.setString(8, routingcode.getProperty(RtcResponseAttribute.MDLN));
				ps.setString(9, routingcode.getProperty(RtcResponseAttribute.MDLT));
				ps.setString(10, routingcode.getProperty(RtcResponseAttribute.PGM));
				ps.setString(11, routingcode.getProperty(RtcResponseAttribute.REG));
				ps.setString(12, routingcode.getProperty(RtcResponseAttribute.REPO));
				ps.setString(13, routingcode.getProperty(RtcResponseAttribute.RINQ));
				ps.setString(14, routingcode.getProperty(RtcResponseAttribute.RPGM));
				ps.setString(15, routingcode.getProperty(RtcResponseAttribute.RTC));
				ps.setString(16, routingcode.getProperty(RtcResponseAttribute.RTMCR));
				ps.setString(17, routingcode.getProperty(RtcResponseAttribute.RTMUP));
				ps.setString(18, routingcode.getProperty(RtcResponseAttribute.TMAC));
				ps.setString(19, routingcode.getProperty(RtcResponseAttribute.TMCR));
				ps.setString(20, routingcode.getProperty(RtcResponseAttribute.TMIM));
				ps.setString(21, routingcode.getProperty(RtcResponseAttribute.TMUP));
				ps.setString(22, routingcode.getProperty(RtcResponseAttribute.WRK));
				ps.setString(23, routingcode.getProperty(RtcResponseAttribute.RTC));
				ps.setString(24, routingcode.getProperty(RtcResponseAttribute.MBR));
				ps.setInt(25, sysplexId);
				ps.setString(26, imsplexName);
				ps.addBatch();
				
				if ((++i) % 1000 == 0) {
					insertionSize += ps.executeBatch().length;
					connection.commit();
					ps.clearBatch();
				}
			}
			
			insertionSize += ps.executeBatch().length;
			connection.commit();
			ps.clearBatch();
			
			//Populate the meta-data with the latest update
			this.autoConfigureResourceMetaData(sysplexId, imsplexName);
			
		} catch (SQLException e) {
	       	try {
					logAndRollback(connection, e);
				} catch (DatastoreException e1) {
					OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
					omDatastoreException.setQuery(sb.toString());
					throw omDatastoreException;
				}
			} finally {
				close(ps); 
				close(connection);
			}

		return insertionSize;
	}
//**************************************************************************************
// Get distinct methods
//**************************************************************************************
	/**
	 * Method will return the distinct (unique) values for a particular column. This is helpful if you want to get 
	 * a list of values that are unique for a column like the unique IMS names or routing code names.
	 * @param sysplexId
	 * @param imsplexName
	 * @param column
	 * @return
	 * @throws OmDatastoreException
	 */
    public Collection<String> getDistinctColumn(int sysplexId,String imsplexName,RtcResponseAttribute column) throws OmDatastoreException{
        return this.getDistinctColumn(sysplexId, imsplexName, column.toString());
    }
	   
//**************************************************************************************
// Get routing code methods
//**************************************************************************************
	public Collection<RoutingCode> getRoutingCodes(int sysplexId) throws OmDatastoreException {
		Collection<RoutingCode> routingCodes	= new ArrayList<RoutingCode>();
		
		try{
			routingCodes =  getRoutingCodes(sysplexId, null, null,null);
		} catch (OmConnectionException e) { 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e){ 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
		return routingCodes;
	}
	
	public Collection<RoutingCode> getRoutingCodes(int sysplexId, String imsplexName) throws OmDatastoreException {
		Collection<RoutingCode> routingCodes	= new ArrayList<RoutingCode>();
		
		try{
			routingCodes =  getRoutingCodes(sysplexId, imsplexName, null,null);
		} catch (OmConnectionException e) { 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e){ 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
		return routingCodes;
	}
	
	public Collection<RoutingCode> getRoutingCodes(int sysplexId,String imsplexName , String[] imsSystemName) throws OmDatastoreException {
		Collection<RoutingCode> routingCodes	= new ArrayList<RoutingCode>();
		
		try{
			routingCodes =  getRoutingCodes(sysplexId, imsplexName, imsSystemName,null);
		} catch (OmConnectionException e) { 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e){ 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
		return routingCodes;
	}
	
	public Collection<RoutingCode> getRoutingCodes(int sysplexId, String imsplexName,String[] imsSystemName,Om om) throws OmDatastoreException, OmException, OmConnectionException {
        Connection connection 	= null;
        PreparedStatement ps 	= null;
        ResultSet results 		= null;
        StringBuffer sb			= null; 
        Collection<RoutingCode> routingCodes		= new ArrayList<RoutingCode>();
        Collection<RoutingCode> routingCodeStatuses = null;
        try {
        	
        	//If the om is not null then query IMS for the routing code status
        	if(om != null && !om.isInteractionModeCache()){
        		
       			EnumSet<QueryRtc.StatusOptions> queryRtcStatusOptionsSet = EnumSet.allOf(QueryRtc.StatusOptions.class);
       			QueryRtc.StatusOptions[] queryRtcStatusOptions = (QueryRtc.StatusOptions[]) queryRtcStatusOptionsSet.toArray(new QueryRtc.StatusOptions[queryRtcStatusOptionsSet.size()]);
    			
       			routingCodeStatuses = om.getRoutingCodeService().getRoutingCodesByStatus(queryRtcStatusOptions,imsSystemName); 

       			if(routingCodeStatuses.size() > 0){
       				this.updateRoutingCodeStatus(routingCodeStatuses,sysplexId,imsplexName);
       			}
        	}

        	connection = parentDatastore.getConnection();
            
        	//Case: no route has been passed or the length is 0 but so we need to check if an impslexname has been passed.
        	if(imsSystemName == null || imsSystemName.length == 0){
        		if(imsplexName != null){
                    sb = new StringBuffer("SELECT * FROM ")
                    .append(this.tableName)
                    .append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
                    .append(" AND ").append(IMSPLX).append(" = ? ")
                    .append(" ORDER BY ").append(RtcResponseAttribute.RTC);
                    
                    ps = connection.prepareStatement(sb.toString());
                    ps.setInt(1, sysplexId);
                    ps.setString(2, imsplexName);
            	}else{
            		 sb = new StringBuffer("SELECT * FROM ")
                     .append(this.tableName)
                     .append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
                     .append(" ORDER BY ").append(RtcResponseAttribute.RTC);
                     
                     ps = connection.prepareStatement(sb.toString());
                     ps.setInt(1, sysplexId);
            	}
        		
        		results = ps.executeQuery();
                
                while (results.next()) {
                    RoutingCode rtc = new RoutingCode(results);
                    routingCodes.add(rtc);
                }
                
        	}else{ //Route has been passed and for each we route the command and concat the results
        		String sqlIn = this.sqlInGenerator(RtcResponseAttribute.MBR.toString(), imsSystemName);
                sb = new StringBuffer("SELECT * FROM ")
                    .append(this.tableName)
                    .append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
                    .append(" AND ").append(IMSPLX).append(" = ? ")
                    .append(sqlIn)
                    .append(" ORDER BY ").append(RtcResponseAttribute.RTC);
                         
                     ps = connection.prepareStatement(sb.toString());
                     ps.setInt(1, sysplexId);
                     ps.setString(2, imsplexName);
                	
                     results = ps.executeQuery();
                    
                     while (results.next()) {
                        RoutingCode rtc = new RoutingCode(results);
                        routingCodes.add(rtc);
                     }
        	}
        	 
        	//Execute process to cleanup the status column in the derby cache
        	this.executeUpdateRoutingcodeColumnAsynchronously(routingCodeStatuses, sysplexId, imsplexName);
        } catch(SQLException e) {
            try {
                logAndRollback(connection, e);
            } catch (DatastoreException e1) {
                OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
                omDatastoreException.setQuery(sb.toString());
                omDatastoreException.setEnvironmentId(sysplexId);
                throw omDatastoreException;
            }
        } finally {
            close(results);    
            close(ps);         
            close(connection); 
        }
        return routingCodes;    
    }
//**************************************************************************************
// Get Routing Codes by name methods
//**************************************************************************************
    public Collection<RoutingCode> getRoutingCodesByName(int sysplexId,String[] routingCodeNames) throws OmDatastoreException {
    	Collection<RoutingCode> routingCodes = new ArrayList<RoutingCode>();
        try {
        	routingCodes = getRoutingCodesByName(sysplexId, null, null,routingCodeNames, null);
    	} catch (OmConnectionException e) { 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e){ 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
        
        return routingCodes;
    }
    
    public Collection<RoutingCode> getRoutingCodesByName(int sysplexId, String imsplexName,String[] routingCodeNames) throws OmDatastoreException {
    	Collection<RoutingCode> routingCodes	= new ArrayList<RoutingCode>();
        try {
        	routingCodes = getRoutingCodesByName(sysplexId, imsplexName, null,routingCodeNames, null);
    	} catch (OmConnectionException e) { 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e){ 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
        
        return routingCodes;
    }
    
    public Collection<RoutingCode> getRoutingCodesByName(int sysplexId, String imsplexName, String [] imsName, String[] routingCodeNames) throws OmDatastoreException {
    	Collection<RoutingCode> routingCodes	= new ArrayList<RoutingCode>();
        try {
        	routingCodes = getRoutingCodesByName(sysplexId, imsplexName, imsName,routingCodeNames, null);
    	} catch (OmConnectionException e) { 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		} catch (OmException e){ 
			/** Will not be thrown because we pass null for the Om, so eat the error **/
		}
        
        return routingCodes;
    }
    
    public Collection<RoutingCode> getRoutingCodesByName(int sysplexId, String imsplexName, String[] imsSystemName, String[] routingCodeNames, Om om) throws OmDatastoreException, OmException, OmConnectionException {
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet results = null;
        ArrayList<RoutingCode> routingCodes = new ArrayList<RoutingCode>();
        StringBuffer sb = null; 
        Collection<RoutingCode> routingCodeStatuses = null;
        
        try{
       		//If the om is not null then query IMS for the transactions status
       		if(om != null && !om.isInteractionModeCache()){
       			EnumSet<QueryRtc.StatusOptions> queryRtcStatusOptionsSet = EnumSet.allOf(QueryRtc.StatusOptions.class);
       			QueryRtc.StatusOptions[] queryRtcStatusOptions = (QueryRtc.StatusOptions[]) queryRtcStatusOptionsSet.toArray(new QueryRtc.StatusOptions[queryRtcStatusOptionsSet.size()]);
    			
       			routingCodeStatuses = om.getRoutingCodeService().getRoutingCodesByStatus(queryRtcStatusOptions,imsSystemName); 
       			
       			if(routingCodeStatuses.size() > 0){
       				this.updateRoutingCodeStatus(routingCodeStatuses,sysplexId,imsplexName);
       			}
       		}
       		
            connection = parentDatastore.getConnection();
            String sqlNameSearch = this.sqlResourceGenerator(RtcResponseAttribute.RTC.toString(), routingCodeNames);
            
            //Case: no route has been passed or the length is 0 but so we need to check if an impslexname has been passed.
            if(imsSystemName == null || imsSystemName.length == 0){
            	if(imsplexName != null){
                   	
                    sb = new StringBuffer("SELECT * FROM ")
                   	.append(this.tableName)
                   	.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
                   	.append(" AND ").append(IMSPLX).append(" = ? ")
                   	.append(sqlNameSearch);
                       
                    ps = connection.prepareStatement(sb.toString());
                    ps.setInt(1, sysplexId);
                    ps.setString(2, imsplexName);
               	}else{
                    	
                    sb = new StringBuffer("SELECT * FROM ")
                   	.append(this.tableName)
                   	.append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
                   	.append(sqlNameSearch);
                        
                     ps = connection.prepareStatement(sb.toString());
                     ps.setInt(1, sysplexId);
               	}
            		
            	results = ps.executeQuery();
                    
                while (results.next()) {
                   RoutingCode rtc = new RoutingCode(results);
                   routingCodes.add(rtc);
                }
                    
            }else{ //Route has been passed and for each we route the command and concat the results
            	
            	String sqlIn = this.sqlInGenerator(RtcResponseAttribute.MBR.toString(), imsSystemName);
                sb = new StringBuffer("SELECT * FROM ")
                   	.append(this.tableName)
                    .append(" WHERE ").append(SYSPLEX_ID).append(" = ? ")
                    .append(" AND ").append(IMSPLX).append(" = ? ")
                    .append(sqlIn)
                    .append(sqlNameSearch);
                        
                    ps = connection.prepareStatement(sb.toString());
                    ps.setInt(1, sysplexId);
                    ps.setString(2, imsplexName);
                        
                    results = ps.executeQuery();
                        
                    while (results.next()) {
                       RoutingCode rtc = new RoutingCode(results);
                       routingCodes.add(rtc);
                    }
            }
            
            //Execute process to cleanup the status column in the derby cache
        	this.executeUpdateRoutingcodeColumnAsynchronously(routingCodeStatuses, sysplexId, imsplexName);
        	
        } catch(SQLException e) {
            try {
                logAndRollback(connection, e);
            } catch (DatastoreException e1) {
                OmDatastoreException omDatastoreException = new OmDatastoreException(e1);
                omDatastoreException.setQuery(sb.toString());
                throw omDatastoreException;
            }
        } finally {
            close(results); 
            close(ps);       
            close(connection); 
        }
        
        return routingCodes;
    }
    
  //**************************************************************************************
 // asynchronous clean up methods
 //**************************************************************************************
       
      /**
       * Executes a callable to clean up the transaction status column, see {link {@link updateTransactionColumnAsynchronously}
       * @param transactionStatuses
       * @param sysplexId
       * @param imsplexName
       * @return
       */
      private int executeUpdateRoutingcodeColumnAsynchronously(Collection<RoutingCode> routingcodeStatuses, int sysplexId,String imsplexName){
     	 int result = 0;
     	 ExecutorService service =  Executors.newSingleThreadExecutor();
     	 UpdateRouingcodesColumnAsynchronously updateRoutingcodesAssychronously = new UpdateRouingcodesColumnAsynchronously(routingcodeStatuses,sysplexId,imsplexName);
         Future<Integer> future = service.submit(updateRoutingcodesAssychronously);
         
          try {
 			result =  future.get();
          } catch (InterruptedException e) {
         	 //TODO: Do anything here?
          } catch (ExecutionException e) {
         	//TODO: Do anything here?
          }
          
          return result;
      }
      
     /**
      * <pre>
      * Class will create a callable to run in the background for a non-blocking call to {@link ImsTransactionTable#updateTransactionColumn(Collection, TransactionResponseAttribute, String, int, int)}
      *
      * Usage:
      *  ExecutorService service =  Executors.newSingleThreadExecutor();
      *  updateTransactionColumnAsynchronously upTransactionsAssychronously = new updateTransactionColumnAsynchronously(transactionStatuses,sysplexId,imsplexId);
      *  Future<Integer> future = service.submit(upTransactionsAssychronously);
      *  try {
      *  	Integer result = future.get();
      *  } catch (InterruptedException e) {
      *  } catch (ExecutionException e) {} 
      * 
      * @author ddimatos
      *</pre>
      */
     private class UpdateRouingcodesColumnAsynchronously implements Callable<Integer> {
     	private Collection<RoutingCode> routingcodeStatuses ;
     	private int sysplexId;
     	private String imsplexName = null;
     	      
     	// Null out the statuses that were set, we want to keep the status column null after use
     	private UpdateRouingcodesColumnAsynchronously(Collection<RoutingCode> routingcodeStatuses, int sysplexId,String imsplexName) {
     		this.routingcodeStatuses = routingcodeStatuses;
     		this.sysplexId = sysplexId;
     		this.imsplexName = imsplexName;
     	}

     	@Override
     	public Integer call() throws OmDatastoreException  {
     		//My guess is this is thread safe because Derby will not allow a read during an update
     		return new Integer (updateRoutingCodeColumn(routingcodeStatuses,RtcResponseAttribute.LSTT,null,sysplexId,imsplexName));
     	}
     }
}

